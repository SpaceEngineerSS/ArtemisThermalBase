"""Cinematic Hero Renderer — thermal-optical composite for GitHub README.

Generates a high-DPI "hero image" by compositing:
- Layer 1: Thermal Map (inferno/magma colormap)
- Layer 2: Illumination Map (hillshade overlay)
- Blending: Multiply the thermal color by the illumination to create
  a 3D-textured "Hillshading" effect

The result is a publication-quality, space-themed composite suitable
for a GitHub repository header image.

Author: Mehmet Gümüş (github.com/SpaceEngineerSS)
"""

from __future__ import annotations

import logging
from pathlib import Path

import matplotlib

matplotlib.use("Agg")

import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
import matplotlib.patheffects as pe
import numpy as np
from matplotlib.cm import ScalarMappable
from scipy.interpolate import griddata

logger = logging.getLogger(__name__)

# ---------------------------------------------------------------------------
# Constants
# ---------------------------------------------------------------------------

_DEFAULT_DPI = 300
_THERMAL_CMAP = "inferno"
_THERMAL_VMIN = 50.0   # K
_THERMAL_VMAX = 400.0  # K
_BG_COLOR = "#07080d"
_TEXT_COLOR = "#e8e8ed"
_ACCENT_COLOR = "#ffa726"
_SUBTITLE_COLOR = "#888e99"


# ---------------------------------------------------------------------------
# Grid Interpolation
# ---------------------------------------------------------------------------


def _scatter_to_grid(
    face_centroids: np.ndarray,
    values: np.ndarray,
    grid_size: int = 800,
    method: str = "linear",
) -> tuple[np.ndarray, np.ndarray, np.ndarray]:
    """Interpolate scattered face data onto a regular grid.

    Parameters
    ----------
    face_centroids : np.ndarray
        (N, 3) face centroids.
    values : np.ndarray
        (N,) scalar values per face.
    grid_size : int
        Number of grid points along each axis.
    method : str
        Interpolation method ('linear', 'nearest', 'cubic').

    Returns
    -------
    xi, yi, grid : tuple
        Regular grid coordinates and interpolated values.
    """
    x = face_centroids[:, 0]
    y = face_centroids[:, 1]

    xi = np.linspace(x.min(), x.max(), grid_size)
    yi = np.linspace(y.min(), y.max(), grid_size)
    xi_mesh, yi_mesh = np.meshgrid(xi, yi)

    grid = griddata(
        (x, y), values,
        (xi_mesh, yi_mesh),
        method=method,
        fill_value=np.nan,
    )

    return xi, yi, grid


# ---------------------------------------------------------------------------
# Composite Renderer
# ---------------------------------------------------------------------------


def render_hero_image(
    face_centroids: np.ndarray,
    thermal_grid: np.ndarray,
    illumination_grid: np.ndarray,
    output_path: Path | str = "output/hero_artemis.png",
    title: str = "ArtemisThermalBase",
    subtitle_left: str = "Lunar South Pole Thermal Simulation",
    subtitle_right: str = "Generated by SpaceEngineerSS",
    cmap_name: str = _THERMAL_CMAP,
    vmin: float = _THERMAL_VMIN,
    vmax: float = _THERMAL_VMAX,
    dpi: int = _DEFAULT_DPI,
    grid_size: int = 800,
    show_scalebar: bool = True,
    show_colorbar: bool = True,
) -> Path:
    """Generate a cinema-quality thermal-optical composite image.

    Blending formula:
        composite_rgb = thermal_rgb × (α + (1 − α) × illum_gray)
    where α ≈ 0.35 ensures shadowed regions are dark but still show
    faint thermal glow, while illuminated regions pop.

    Parameters
    ----------
    face_centroids : np.ndarray
        (N, 3) face centroids.
    thermal_grid : np.ndarray
        (N,) surface temperatures [K].
    illumination_grid : np.ndarray
        (N,) illumination fractions [0, 1].
    output_path : Path or str
        Output file path.
    title : str
        Main title text.
    subtitle_left : str
        Left subtitle (description).
    subtitle_right : str
        Right subtitle (author credit).
    cmap_name : str
        Matplotlib colormap name.
    vmin, vmax : float
        Temperature range for normalization.
    dpi : int
        Output resolution.
    grid_size : int
        Interpolation grid resolution.
    show_scalebar : bool
        Add a scale bar.
    show_colorbar : bool
        Add a horizontal colorbar.

    Returns
    -------
    Path
        Path to the saved image.
    """
    output_path = Path(output_path)
    output_path.parent.mkdir(parents=True, exist_ok=True)

    logger.info("Rendering hero image (%dx%d grid, %d DPI)...", grid_size, grid_size, dpi)

    # Step 1: Interpolate scattered data onto regular grid
    xi, yi, thermal_2d = _scatter_to_grid(face_centroids, thermal_grid, grid_size)
    _, _, illum_2d = _scatter_to_grid(face_centroids, illumination_grid, grid_size, method="nearest")

    # Step 2: Normalize and colormap the thermal data
    norm = mcolors.Normalize(vmin=vmin, vmax=vmax)
    cmap = plt.get_cmap(cmap_name)
    thermal_rgb = cmap(norm(np.nan_to_num(thermal_2d, nan=vmin)))  # (H, W, 4) RGBA

    # Step 3: Build composite with alpha-blended hillsharing
    # Blend: composite = thermal_rgb * (alpha + (1-alpha) * illumination)
    alpha_blend = 0.35
    illum_factor = alpha_blend + (1.0 - alpha_blend) * np.nan_to_num(illum_2d, nan=0.0)
    illum_factor = np.clip(illum_factor, 0.0, 1.0)

    composite = thermal_rgb.copy()
    composite[:, :, 0] *= illum_factor  # R
    composite[:, :, 1] *= illum_factor  # G
    composite[:, :, 2] *= illum_factor  # B
    # Keep alpha channel at 1.0 for valid pixels, 0 for NaN
    valid_mask = ~np.isnan(thermal_2d)
    composite[:, :, 3] = valid_mask.astype(np.float64)

    # Step 4: Create figure
    fig_width = 16
    fig_height = 10
    fig = plt.figure(figsize=(fig_width, fig_height), facecolor=_BG_COLOR, dpi=dpi)

    # Main image axis (spanning most of the figure)
    ax = fig.add_axes([0.05, 0.12, 0.88, 0.78])
    ax.set_facecolor(_BG_COLOR)

    # Extent in meters
    extent = [xi.min(), xi.max(), yi.min(), yi.max()]
    ax.imshow(
        composite,
        extent=extent,
        origin="lower",
        aspect="equal",
        interpolation="bilinear",
    )

    ax.set_xlim(extent[0], extent[1])
    ax.set_ylim(extent[2], extent[3])

    # Remove axis ticks and spines for clean look
    ax.set_xticks([])
    ax.set_yticks([])
    for spine in ax.spines.values():
        spine.set_visible(False)

    # Step 5: Title and subtitles
    text_glow = [pe.withStroke(linewidth=3, foreground="#00000088")]

    fig.text(
        0.5, 0.95,
        title,
        fontsize=20, fontweight="bold", color=_TEXT_COLOR,
        ha="center", va="top",
        fontfamily="monospace",
        path_effects=text_glow,
    )
    fig.text(
        0.5, 0.915,
        subtitle_left,
        fontsize=11, color=_ACCENT_COLOR,
        ha="center", va="top",
        fontfamily="monospace",
        style="italic",
    )
    fig.text(
        0.93, 0.04,
        subtitle_right,
        fontsize=8, color=_SUBTITLE_COLOR,
        ha="right", va="bottom",
        fontfamily="monospace",
    )

    # Step 6: Horizontal colorbar
    if show_colorbar:
        cbar_ax = fig.add_axes([0.15, 0.06, 0.70, 0.025])
        sm = ScalarMappable(norm=norm, cmap=cmap)
        sm.set_array([])
        cbar = fig.colorbar(
            sm, cax=cbar_ax, orientation="horizontal",
        )
        cbar.ax.tick_params(colors=_TEXT_COLOR, labelsize=8)
        cbar.set_label(
            "Surface Temperature [K]",
            color=_TEXT_COLOR, fontsize=10, fontfamily="monospace",
        )
        cbar.outline.set_edgecolor("#333")

    # Step 7: Scale bar
    if show_scalebar:
        _draw_scale_bar(ax, extent, bar_length_m=1000.0, label="1 km")

    # Step 8: Save
    fig.savefig(
        output_path,
        dpi=dpi,
        facecolor=fig.get_facecolor(),
        bbox_inches="tight",
        pad_inches=0.1,
    )
    plt.close(fig)

    file_size_mb = output_path.stat().st_size / 1e6
    logger.info(
        "Hero image saved: %s (%.1f MB, %d DPI)",
        output_path, file_size_mb, dpi,
    )

    return output_path


def _draw_scale_bar(
    ax: plt.Axes,
    extent: list[float],
    bar_length_m: float = 1000.0,
    label: str = "1 km",
) -> None:
    """Draw a scale bar in the lower-left corner of the plot.

    Parameters
    ----------
    ax : matplotlib.axes.Axes
        Axes to draw on.
    extent : list[float]
        [xmin, xmax, ymin, ymax] in meters.
    bar_length_m : float
        Scale bar length in meters.
    label : str
        Scale bar label text.
    """
    x_range = extent[1] - extent[0]
    y_range = extent[3] - extent[2]

    # Position: lower-left with small margin
    x_start = extent[0] + 0.06 * x_range
    y_pos = extent[2] + 0.08 * y_range

    # Draw bar
    ax.plot(
        [x_start, x_start + bar_length_m],
        [y_pos, y_pos],
        color="white", linewidth=2.5,
        solid_capstyle="butt",
    )
    # End ticks
    tick_h = 0.015 * y_range
    for x in [x_start, x_start + bar_length_m]:
        ax.plot(
            [x, x], [y_pos - tick_h, y_pos + tick_h],
            color="white", linewidth=1.5,
        )
    # Label
    ax.text(
        x_start + bar_length_m / 2, y_pos + tick_h * 2.5,
        label,
        color="white", fontsize=9,
        ha="center", va="bottom",
        fontfamily="monospace",
        path_effects=[pe.withStroke(linewidth=2, foreground="#00000088")],
    )


# ---------------------------------------------------------------------------
# Standalone CLI
# ---------------------------------------------------------------------------


def render_from_saved_data(
    data_dir: Path | str = "output",
    output_path: Path | str | None = None,
    **kwargs,
) -> Path:
    """Load saved results and render a hero image.

    Parameters
    ----------
    data_dir : Path or str
        Directory with saved .npy files.
    output_path : Path or str, optional
        Override output path.
    **kwargs
        Extra arguments passed to render_hero_image.

    Returns
    -------
    Path
        Path to the saved hero image.
    """
    from simulation.io_manager import load_results

    data = load_results(data_dir)

    if data["thermal_grid"] is None or data["face_centroids"] is None:
        raise FileNotFoundError(
            f"Missing required data files in {data_dir}. "
            "Run the simulation first with: python main.py --duration 1"
        )

    if output_path is None:
        output_path = Path(data_dir) / "hero_artemis.png"

    return render_hero_image(
        face_centroids=data["face_centroids"],
        thermal_grid=data["thermal_grid"],
        illumination_grid=data["illumination_grid"],
        output_path=output_path,
        **kwargs,
    )


if __name__ == "__main__":
    import sys

    logging.basicConfig(level=logging.INFO, stream=sys.stdout)
    data_dir = sys.argv[1] if len(sys.argv) > 1 else "output"
    path = render_from_saved_data(data_dir)
    logger.info("Hero image saved: %s", path)
